/~
   /*
   ---------------------------------------------------------------------------
   Copyright 2014 Murray Lang

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
   --------------------------------------------------------------------------

   The format of this file is as specified for JS/CC:
		http://jscc.phorward-software.com/
   Kudos to Jan Max Meyer for providing such a useful tool free of charge.

   This file describes a parser for a variant of the Logo programming language.
   It's based on Cricket Logo, but I've endeavoured to provide a somewhat more
   comprehensive set of Logo language features. I've used Berkley Logo as my
   reference and have not added any key words that are not in the Berkley
   standard.
   */
~/
	
	
[*

var Types                   = require('../../common/Types');
var AST                     = require('../../common/Ast');
var langAst                    = require('../common/CompilerAst');
var ConfigNode              = require('../../common/ConfigNode').ConfigNode;
var ConfigNodeSource        = require('../../common/ConfigNode').ConfigNodeSource;
var CompilerNodeType        = require('../common/AstNodes/NodeType');
var VariableNode            = require('../common/AstNodes/VariableNode').VariableNode;
var VariableNodeKind        = require('../common/AstNodes/VariableNode').VariableNodeKind;
var VarAssignmentNode       = require('../common/AstNodes/VarAssignmentNode').VarAssignmentNode;
var VarAssignmentNodeKind   = require('../common/AstNodes/VarAssignmentNode').VarAssignmentNodeKind;
var _ImmediateNode           = require('../common/AstNodes/ImmediateNode').ImmediateNode;
var createStringLiteralNode = require('../common/AstNodes/ImmediateNode').createStringLiteralNode;
var ProcedureNode           = require('../common/AstNodes/ProcedureNode');
var ControlNode             = require('../common/AstNodes/ControlNode').ControlNode;
var ControlNodeKind         = require('../common/AstNodes/ControlNode').ControlNodeKind;
var CallNode                = require('../common/AstNodes/CallNode');
var ArgumentsNode           = require('../common/AstNodes/ArgumentsNode').ArgumentsNode;
var concatArguments         = require('../common/AstNodes/ArgumentsNode').concatArguments;
var ListNode                = require('../../common/ListNode');
var CommandNode             = require('../common/AstNodes/CommandNode').CommandNode;
var CommandNodeKind         = require('../common/AstNodes/CommandNode').CommandNodeKind;
var MotorNode               = require('../common/AstNodes/MotorNode').MotorNode;
var MotorNodeKind           = require('../common/AstNodes/MotorNode').MotorNodeKind;
var setMotorsToken          = require('../common/AstNodes/MotorNode').setMotorsToken;
var VarFetchNode            = require('../common/AstNodes/VarFetchNode').VarFetchNode;
var VarFetchNodeKind        = require('../common/AstNodes/VarFetchNode').VarFetchNodeKind;
var ExpressionNode          = require('../common/AstNodes/ExpressionNode').ExpressionNode;
var ExpressionNodeKind      = require('../common/AstNodes/ExpressionNode').ExpressionNodeKind;
var DeclarationNode         = require('../common/AstNodes/DeclarationNode').DeclarationNode;
var DeclarationNodeKind     = require('../common/AstNodes/DeclarationNode').DeclarationNodeKind;
var createArrayDeclaration  = require('../common/AstNodes/DeclarationNode').createArrayDeclaration;
var createStringDeclaration = require('../common/AstNodes/DeclarationNode').createStringDeclaration;
var setDeclarationToken     = require('../common/AstNodes/DeclarationNode').setDeclarationToken;
var InputNode               = require('../common/AstNodes/InputNode').InputNode;
var InputNodeKind           = require('../common/AstNodes/InputNode').InputNodeKind;
var BlockNode               = require('../common/AstNodes/BlockNode');
//var libraries               = require('../../lib/Libraries');

var _ast = new AST.AbstractSyntaxTree();
var lang = "logo";

function buildConfigPath(lhs, rhs)
{
    var result = lhs;
    if (result === undefined)
        result = [];

    result.push(rhs);
    return result;
}

function buildConfigNode(token, ids, nodes)
    {
        // The first part of the ID is the library name
        var library  = ids[0].value;
        var configObj = createConfigObject(ids);

        var parent = configObj;
        // Traverse the object to find the item's parent (skip the library name)
        // The item's parent is the second-last object. It will pe used to
        // access the item using the item's name (the last array member).
        for (var i = 1; i < ids.length - 1; i++)
            parent = parent[ids[i].value];

        parent[ids[ids.length-1].value] = buildConfigParams(nodes);

        return new ConfigNode(token, ConfigNodeSource.compiler, library, configObj);
    }

function createConfigObject(ids)
{
    var result = {};
    var nextLevel = result;
        // Start at 1 to skip the library name
    for (var i = 1; i < ids.length; i++)
    {
        nextLevel[ids[i].value] = {};
        nextLevel = nextLevel[ids[i].value];
    }
    return result;
}

/**
 * Return either an object or an array, representing the configuration.
 *
 * The GenericNode argument contains either a list of values or a list of
 * assignments. If it's a list of values then return an array of those values.
 * If it's a list of assignments then return an object with the lhs of the
 * assignments being the object member names and the rhs of the assignments
 * being the values of those members. The rhs of the assignments must be
 * immediate values.
 * @param nodes a GenericNode containing the config assignments
 */
function buildConfigParams(nodes)
    {
        result = {};
        var items = nodes.children;
        if (items.length == 0)
            return result;
        var result;
        if (items[0].nodeType != CompilerNodeType.assignment)
            return result;

            // Assume that all items are assignments.
            //Populate the config object based on the assignments
        for (var i = 0; i < items.length; i++)
        {
            var name = items[i].variable.value;
            var rhs = items[i].children[0];
                // If the rhs is an ImmediateNode then just copy the value.
                // Otherwise, if it's a list then copy an array with the items.
            if (rhs.nodeType == CompilerNodeType.immediate)
            {
                result[name] = rhs.value;
            }
            else if (rhs.nodeType == "list")
            {
                    // Build an array with the list items.
                    // Assume all children are ImmediateNodes
                var rhsArray = [];
                for (var j = 0; j < rhs.children.length; j++)
                    rhsArray.push(rhs.children[j].value);

                result[name] = rhsArray;
            }
        }
        return result;
     }

*]
!	" |\r|\n|\t|;[^\n\r]*[\n\r]"

    "config"                                        [* %match = { value: %match, token: %match, offset: %offset}; *]
    "fw|forward"                    Forward         [* %match = { value: %match, token: %match, offset: %offset}; *]
    "bw|backward"                   Backward        [* %match = { value: %match, token: %match, offset: %offset}; *]
    "lt|left"                       Left            [* %match = { value: %match, token: %match, offset: %offset}; *]
    "rt|right"                      Right           [* %match = { value: %match, token: %match, offset: %offset}; *]
    "pd|pendown"                    PenDown         [* %match = { value: %match, token: %match, offset: %offset}; *]
    "pu|penup"                      PenUp           [* %match = { value: %match, token: %match, offset: %offset}; *]
    "config"                                        [* %match = { value: %match, token: %match, offset: %offset}; *]
	"if"                                            [* %match = { value: %match, token: %match, offset: %offset}; *]
	"ifelse"                                        [* %match = { value: %match, token: %match, offset: %offset}; *]
	"repeat"                                        [* %match = { value: %match, token: %match, offset: %offset}; *]
	"loop"                                          [* %match = { value: %match, token: %match, offset: %offset}; *]
	"for"                                           [* %match = { value: %match, token: %match, offset: %offset}; *]
	"foreach"                                       [* %match = { value: %match, token: %match, offset: %offset}; *]
	"forever"                                       [* %match = { value: %match, token: %match, offset: %offset}; *]
	"while"                                         [* %match = { value: %match, token: %match, offset: %offset}; *]
	"do\.while"						DoWhile         [* %match = { value: %match, token: %match, offset: %offset}; *]
	"to"                                            [* %match = { value: %match, token: %match, offset: %offset}; *]
	"end"                                           [* %match = { value: %match, token: %match, offset: %offset}; *]
	"tag"                                           [* %match = { value: %match, token: %match, offset: %offset}; *]
	"goto"                                          [* %match = { value: %match, token: %match, offset: %offset}; *]
	"stop"                                          [* %match = { value: %match, token: %match, offset: %offset}; *]
	"make"                                          [* %match = { value: %match, token: %match, offset: %offset}; *]
	"wait"                                          [* %match = { value: %match, token: %match, offset: %offset}; *]
	"waitms"                                        [* %match = { value: %match, token: %match, offset: %offset}; *]
	"waituntil"                                     [* %match = { value: %match, token: %match, offset: %offset}; *]
	"ledon"                                         [* %match = { value: %match, token: %match, offset: %offset}; *]
	"ledoff"                                        [* %match = { value: %match, token: %match, offset: %offset}; *]
	"beep"                                          [* %match = { value: %match, token: %match, offset: %offset}; *]
	"on"                                            [* %match = { value: %match, token: %match, offset: %offset}; *]
	"onfor"                                         [* %match = { value: %match, token: %match, offset: %offset}; *]
	"off"                                           [* %match = { value: %match, token: %match, offset: %offset}; *]
	"thisway"                                       [* %match = { value: %match, token: %match, offset: %offset}; *]
	"thatway"                                       [* %match = { value: %match, token: %match, offset: %offset}; *]
	"rd"                                            [* %match = { value: %match, token: %match, offset: %offset}; *]
	"brake"                                         [* %match = { value: %match, token: %match, offset: %offset}; *]
	"setpower"                                      [* %match = { value: %match, token: %match, offset: %offset}; *]
	"and"                                           [* %match = { value: %match, token: %match, offset: %offset}; *]
	"or"                                            [* %match = { value: %match, token: %match, offset: %offset}; *]
	"xor"                                           [* %match = { value: %match, token: %match, offset: %offset}; *]
	"not"                                           [* %match = { value: %match, token: %match, offset: %offset}; *]
	"bitand"                                        [* %match = { value: %match, token: %match, offset: %offset}; *]
    "bitor"                                         [* %match = { value: %match, token: %match, offset: %offset}; *]
    "bitxor"                                        [* %match = { value: %match, token: %match, offset: %offset}; *]
    "bitnot"                                        [* %match = { value: %match, token: %match, offset: %offset}; *]
    "ashift"                                        [* %match = { value: %match, token: %match, offset: %offset}; *]
    "lshift"                                        [* %match = { value: %match, token: %match, offset: %offset}; *]
    "rotate"                                        [* %match = { value: %match, token: %match, offset: %offset}; *]
	"true"                                          [* %match = { value: %match, token: %match, offset: %offset}; *]
	"false"                                         [* %match = { value: %match, token: %match, offset: %offset}; *]
	"timer"                                         [* %match = { value: %match, token: %match, offset: %offset}; *]
	"resett"                                        [* %match = { value: %match, token: %match, offset: %offset}; *]
	"random"                                        [* %match = { value: %match, token: %match, offset: %offset}; *]
	"setsvh"                                        [* %match = { value: %match, token: %match, offset: %offset}; *]
	"svr"                                           [* %match = { value: %match, token: %match, offset: %offset}; *]
	"svl"                                           [* %match = { value: %match, token: %match, offset: %offset}; *]
	"resetdp"                                       [* %match = { value: %match, token: %match, offset: %offset}; *]
    "setdp"                                         [* %match = { value: %match, token: %match, offset: %offset}; *]
	"record"                                        [* %match = { value: %match, token: %match, offset: %offset}; *]
	"recall"                                        [* %match = { value: %match, token: %match, offset: %offset}; *]
	"erase"                                         [* %match = { value: %match, token: %match, offset: %offset}; *]
	"send"                                          [* %match = { value: %match, token: %match, offset: %offset}; *]
	"receive"                                       [* %match = { value: %match, token: %match, offset: %offset}; *]
	"ethernet"                                      [* %match = { value: %match, token: %match, offset: %offset}; *]
	"received\?"					Received        [* %match = { value: %match, token: %match, offset: %offset}; *]
	"repcount"                                      [* %match = { value: %match, token: %match, offset: %offset}; *]
    "thing"                                         [* %match = { value: %match, token: %match, offset: %offset}; *]
    "i2cstart"                                      [* %match = { value: %match, token: %match, offset: %offset}; *]
    "i2cstop"                                       [* %match = { value: %match, token: %match, offset: %offset}; *]
    "i2cwrite"                                       [* %match = { value: %match, token: %match, offset: %offset}; *]
    "i2cread"                                         [* %match = { value: %match, token: %match, offset: %offset}; *]
    "i2cerr"                                        [* %match = { value: %match, token: %match, offset: %offset}; *]
    "encode"                                         [* %match = { value: %match, token: %match, offset: %offset}; *]
    "decode"                                         [* %match = { value: %match, token: %match, offset: %offset}; *]
    "int16"                                         [* %match = { value: %match, token: %match, offset: %offset}; *]
    "uint16"                                         [* %match = { value: %match, token: %match, offset: %offset}; *]
    "int32"                                         [* %match = { value: %match, token: %match, offset: %offset}; *]
    "uint32"                                         [* %match = { value: %match, token: %match, offset: %offset}; *]
    "float"                                         [* %match = { value: %match, token: %match, offset: %offset}; *]
    "double"                                         [* %match = { value: %match, token: %match, offset: %offset}; *]
	"#"
	","
	"sensor[1-8]"						Sensorn     [* %match = { value: %match.substr( 6, 1 ), token: %match, offset: %offset}; *]
	"switch[1-8]"						Switchn     [* %match = { value: %match.substr( 6, 1 ), token: %match, offset: %offset}; *]
    "digitalin"                                     [* %match = { value: %match, token: %match, offset: %offset}; *]
    "digitalout"                                    [* %match = { value: %match, token: %match, offset: %offset}; *]
    "analogin"                                      [* %match = { value: %match, token: %match, offset: %offset}; *]
    "analogout"                                     [* %match = { value: %match, token: %match, offset: %offset}; *]
    "array"                                         [* %match = { value: %match, token: %match, offset: %offset}; *]
    "bytearray"                                     [* %match = { value: %match, token: %match, offset: %offset}; *]
    "aset"                                          [* %match = { value: %match, token: %match, offset: %offset}; *]
    "aget"                                          [* %match = { value: %match, token: %match, offset: %offset}; *]
    "setitem"                                       [* %match = { value: %match, token: %match, offset: %offset}; *]
    "item"                                          [* %match = { value: %match, token: %match, offset: %offset}; *]
    "local"                                         [* %match = { value: %match, token: %match, offset: %offset}; *]
    "min"                                           [* %match = { value: %match, token: %match, offset: %offset}; *]
    "max"                                           [* %match = { value: %match, token: %match, offset: %offset}; *]
    "abs"                                           [* %match = { value: %match, token: %match, offset: %offset}; *]
    "neg"                                           [* %match = { value: %match, token: %match, offset: %offset}; *]
    "pow"                                           [* %match = { value: %match, token: %match, offset: %offset}; *]
    "sqr"                                           [* %match = { value: %match, token: %match, offset: %offset}; *]
    "sqrt"                                          [* %match = { value: %match, token: %match, offset: %offset}; *]
    "exp"                                           [* %match = { value: %match, token: %match, offset: %offset}; *]
    "sin"                                           [* %match = { value: %match, token: %match, offset: %offset}; *]
    "cos"                                           [* %match = { value: %match, token: %match, offset: %offset}; *]
    "tan"                                           [* %match = { value: %match, token: %match, offset: %offset}; *]
    "asin"                                          [* %match = { value: %match, token: %match, offset: %offset}; *]
    "acos"                                          [* %match = { value: %match, token: %match, offset: %offset}; *]
    "atan"                                          [* %match = { value: %match, token: %match, offset: %offset}; *]
    "atan2"                                         [* %match = { value: %match, token: %match, offset: %offset}; *]
    "sinh"                                          [* %match = { value: %match, token: %match, offset: %offset}; *]
    "cosh"                                          [* %match = { value: %match, token: %match, offset: %offset}; *]
    "tanh"                                          [* %match = { value: %match, token: %match, offset: %offset}; *]
    "hypot"                                         [* %match = { value: %match, token: %match, offset: %offset}; *]
    "ln"                                            [* %match = { value: %match, token: %match, offset: %offset}; *]
    "log10"                                         [* %match = { value: %match, token: %match, offset: %offset}; *]

    "round"      Round                             [* %match = { value: %match, token: %match, offset: %offset}; *]
    "trunc"    Trunc                           [* %match = { value: %match, token: %match, offset: %offset}; *]
    "floor"    Floor                           [* %match = { value: %match, token: %match, offset: %offset}; *]
    "ceil"     Ceil                            [* %match = { value: %match, token: %match, offset: %offset}; *]

    "isnan"    IsNan                           [* %match = { value: %match, token: %match, offset: %offset}; *]
    "isinf"    IsInf                           [* %match = { value: %match, token: %match, offset: %offset}; *]
    "string"                                        [* %match = { value: %match, token: %match, offset: %offset}; *]
    "tostring"                                      [* %match = { value: %match, token: %match, offset: %offset}; *]
    "ascii"                                         [* %match = { value: %match, token: %match, offset: %offset}; *]
    "count"                                         [* %match = { value: %match, token: %match, offset: %offset}; *]
    "\["                                            [* %match = { value: %match, token: %match, offset: %offset}; *]
	"\]"                                            [* %match = { value: %match, token: %match, offset: %offset}; *]
	"\("
    "\)"
    "output"                            Output      [* %match = { value: %match,       token: %match, offset: %offset}; *]
    "E"                                             [* %match = { value: Math.E,       token: %match, offset: %offset}; *]
    "PI"                                            [* %match = { value: Math.PI,      token: %match, offset: %offset}; *]
    "LN2"                                           [* %match = { value: Math.LN2,     token: %match, offset: %offset}; *]
    "LN10"                                          [* %match = { value: Math.LN10,    token: %match, offset: %offset}; *]
    "LOG2E"                                         [* %match = { value: Math.LOG2E,   token: %match, offset: %offset}; *]
    "LOG10E"                                        [* %match = { value: Math.LOG10E,  token: %match, offset: %offset}; *]
    "SQRT1_2"                                       [* %match = { value: Math.SQRT1_2, token: %match, offset: %offset}; *]
    "SQRT2"                                         [* %match = { value: Math.SQRT2,   token: %match, offset: %offset}; *]

    
    "\"[A-Za-z_][A-Za-z0-9_]*[%&!#\$\?]?"	NameOf	    [* %match = { value: %match.substr( 1, %match.length - 1 ), token: %match, offset: %offset}; *]
    "[A-Za-z_][A-Za-z0-9_]*\""			Label		[* %match = { value: %match.substr( 0, %match.length - 1 ), token: %match, offset: %offset}; *]
    "\:[A-Za-z_][A-Za-z0-9_]*[%&!#\$\?]?"	ValueOf	    [* %match = { value: %match.substr( 1, %match.length - 1 ), token: %match, offset: %offset}; *]
	"[A-Za-z_][A-Za-z0-9_]*[%&!#\$\?]?"	Identifier  [* %match = { value: %match, token: %match, offset: %offset}; *]
    "[a-h]+,"			    			Motors		[* %match = { value: %match.substr( 0, %match.length - 1 ), token: %match, offset: %offset}; *]
    "[n-u]+,"			    			Servos		[* %match = { value: %match.substr( 0, %match.length - 1 ), token: %match, offset: %offset}; *]
    "\'([^\']|\'\')*\'"					StringLit		[* var value = %match.substr( 1, %match.length - 2 );
                                                       value = value.replace( /''/g, "\'" );
                                                       %match = { value: value, token: %match, offset: %offset};
                                                     *]

    "-?[0-9]+S?"						Short		[* var value;
                                                       if (%match.charAt(%match.length - 1) == 'S')
                                                           value = %match.substr( 0, %match.length - 1);
                                                       else
                                                           value = %match.substr( 0, %match.length);
                                                       %match = { value: value, token: %match, offset: %offset};
                                                     *]
    "[0-9]+US"							UShort		[* %match = { value: %match.substr( 0, %match.length - 2 ), token: %match, offset: %offset}; *]
    "-?[0-9]+I"							Integer		[* %match = { value: %match.substr( 0, %match.length - 1 ), token: %match, offset: %offset}; *]
    "[0-9]+UI"						    UInteger	[* %match = { value: %match.substr( 0, %match.length - 2 ), token: %match, offset: %offset}; *]

    "[0-9]*\.[0-9]*F?"	                Float		[* var value;
                                                       if (%match.charAt(%match.length - 1) == 'F')
                                                           value = %match.substr( 0, %match.length - 1);
                                                       else
                                                           value = %match.substr( 0, %match.length);
                                                       %match = { value: value, token: %match, offset: %offset};
                                                     *]
    "[0-9]*\.[0-9]*R"	                Double		[* %match = { value: %match.substr( 0, %match.length - 1 ), token: %match, offset: %offset}; *]
    ;


/~ Operators to be used in expressions ~/
>	"="                     [* %match = { value: %match, token: %match, offset: %offset}; *]
	"<>"                    [* %match = { value: %match, token: %match, offset: %offset}; *]
	"<="                    [* %match = { value: %match, token: %match, offset: %offset}; *]
	">="                    [* %match = { value: %match, token: %match, offset: %offset}; *]
	">"                     [* %match = { value: %match, token: %match, offset: %offset}; *]
	"<"                     [* %match = { value: %match, token: %match, offset: %offset}; *]
	;


<	"\+"                    [* %match = { value: %match, token: %match, offset: %offset}; *]
	"sum"                   [* %match = { value: %match, token: %match, offset: %offset}; *]
	"\-"                    [* %match = { value: %match, token: %match, offset: %offset}; *]
	"difference"            [* %match = { value: %match, token: %match, offset: %offset}; *]
	;

<	"/"                     [* %match = { value: %match, token: %match, offset: %offset}; *]
	"quotient"              [* %match = { value: %match, token: %match, offset: %offset}; *]
	"\*"                    [* %match = { value: %match, token: %match, offset: %offset}; *]
	"product"               [* %match = { value: %match, token: %match, offset: %offset}; *]
	"%"                     [* %match = { value: %match, token: %match, offset: %offset}; *]
	"modulo"                [* %match = { value: %match, token: %match, offset: %offset}; *]
	;

<   "not"                   [* %match = { value: %match, token: %match, offset: %offset}; *]
	"and"                   [* %match = { value: %match, token: %match, offset: %offset}; *]
	"or"                    [* %match = { value: %match, token: %match, offset: %offset}; *]
	"xor"                   [* %match = { value: %match, token: %match, offset: %offset}; *]
	;


##

Program:			Program Stmt									[* if (%2 !== undefined && %2 != null)
																		{
																			_ast.appendNode(%2);
																		} 
																	*]
					|
					;

TurtleStmt:         Forward Expression          [* %% = new CommandNode(CommandNodeKind.forward, %1, %2); *]
					| Backward Expression       [* %% = new CommandNode(CommandNodeKind.backward, %1, %2); *]
					| Left Expression           [* %% = new CommandNode(CommandNodeKind.left, %1, %2); *]
					| Right Expression          [* %% = new CommandNode(CommandNodeKind.right, %1, %2); *]
					| PenUp                     [* %% = new CommandNode(CommandNodeKind.penup, %1); *]
					| PenDown                   [* %% = new CommandNode(CommandNodeKind.pendown, %1); *]
					;


ConfigStmt:         config '[' ConfigIds ']' '[' ParamAssignments ']'    [* %% = buildConfigNode(%1, %3, %6); *]
					;

ConfigIds:          ConfigIds ConfigId                [* %% = buildConfigPath(%1, %2); *]
          		    |                                 [* *]
          		    ;

ConfigId:             Identifier
          		    | digitalin
          		    ;

ParamAssignments:   ParamAssignments ParamAssignment   [* %% = AST.concatNodes(%1, %2);*]
                    |
                    ;

ParamAssignment:    make NameOf ParamSetting           [* %% = new VarAssignmentNode(%1, %2, VarAssignmentNodeKind.make, %3); *]
                    ;

ParamSetting:         ParamValue
                    | '[' ParamValueList ']'            [* %% = new ListNode(%2); *]
                    ;

ParamValueList:     ParamValueList  ParamValue          [* %% = AST.concatNodes(%1, %2); *]
                    |
                    ;

ParamValue:           StringLit         [* %% = createStringLiteralNode(%1); *]
                    | IntLike
                    | Double            [* %% = new _ImmediateNode([Types.double], %1); *]
                    | Float             [* %% = new _ImmediateNode([Types.float], %1); *]
                    | true              [* %% = new _ImmediateNode([Types.bool], %1); *]
                    | false             [* %% = new _ImmediateNode([Types.bool], %1); *]
                    ;

Block:				'[' Block_Stmt_List ']'				[* %% = new BlockNode(%1, %2, %3); *]
					;


Block_Stmt:			Stmt
					|
					;

Block_Stmt_List:	Block_Stmt_List Block_Stmt		[* %% = AST.concatNodes(%1, %2); *]
					|
					;

Proc_Stmt_List:		Proc_Stmt_List Proc_Stmt		[* %% = AST.concatNodes(%1, %2); *]
					|
					;

Proc_Stmt:			Stmt
                    |
                    ;

Waituntil_Block:    '[' Waituntil_Stmt_List ']'     [* %% = new BlockNode(%1, %2, %3); *]
                    ;

Waituntil_Stmt_List:   Block_Stmt_List Expression   [* %% = AST.concatNodes(%1, %2); *]
                    ;

DecodeType:           int16
                    | uint16
                    | int32
                    | uint32
                    | float
                    | double
                    | string
                    ;

ListLike:           List
                    | encode Variable Expression             [* %% = new CommandNode(CommandNodeKind.encode, %1, %2, %3); *]
                    | decode DecodeType Variable Expression  [* %% = new CommandNode(CommandNodeKind.decode, %1, %2, %3, %4); *]
                    | '(' ListLike ')'                    [* %% = %2; *]
                    ;

List:               '[' ListItems ']'                       [* %% = new ListNode(%2); *]
                    ;

ListItems:          ListItems Expression                    [* %% = AST.concatNodes(%1, %2); *]
					|
					;

Param_List:			Param_List Param					    [* %% = AST.concatNodes(%1, %2); *]
					|
					;

Param:				ValueOf '[' ']'                        [* %% = new VariableNode(%1, VariableNodeKind.parameter, [Types.array(0), Types.unknown]); *]
					| ValueOf                              [* %% = new VariableNode(%1, VariableNodeKind.parameter); *]
					;

ProcDef:			to Identifier Param_List Proc_Stmt_List end		[* %% = new ProcedureNode(%2, [Types.unknown], %3, %4); *]
					;


ArraySpec:          Identifier IntLike                      [* %% = createArrayDeclaration(%1, %2); *]
					;

Variable:           NameOf                                [* %% = new VariableNode(%1, VariableNodeKind.nameof); *]
                    | ValueOf                                 [* %% = new VariableNode(%1, VariableNodeKind.valueof); *]
					;

ThingVar:            Variable
					| thing ThingVar                        [* %% = langAst.incrementThings(%2); *]
					| '(' ThingVar ')'                      [* %% = %2; *]
					;

Arg_List:		Arg_List Arg								[* %% = concatArguments(%1, %2);*]
				|
				;

Arg:            Expression
                | NameOf                                [* %% = new VariableNode(%1, VariableNodeKind.nameof); *]
				;

ProcCall:		Identifier Arg_List					    [* %% = new CallNode(%1, %2); *]
                | '(' ProcCall ')'                      [* %% = %2; *]
				;

ProcCallNoArg:  Identifier 								[* %% = new CallNode(%1); *]
                | '(' ProcCallNoArg ')'                 [* %% = %2; *]
				;

SendArray:      send Expression Variable Expression   [* %% = new CommandNode(CommandNodeKind.send, %1, %2, %3, %4); *]
                | '(' SendArray ')'                   [* %% = %2; *]
     			;

ReceiveArray:   receive Expression Variable Expression Expression   [* %% = new CommandNode(CommandNodeKind.receive, %1, %2, %3, %4, %5); *]
                | '(' ReceiveArray ')'                               [* %% = %2; *]
     			;


Stmt:	ConfigStmt
        | TurtleStmt
        | if Expression Block 							    [* %% = new ControlNode(ControlNodeKind.if, %1, %2, %3); *]
        | ifelse Expression Block Block 				    [* %% = new ControlNode(ControlNodeKind.ifelse, %1, %2, %3, %4); *]
        | repeat Expression Block						   	[* %% = new ControlNode(ControlNodeKind.repeat, %1, %2, %3); *]
        | loop Block										[* %% = new ControlNode(ControlNodeKind.forever, %1, %2); *]
        | for '[' Identifier Expression Expression NegExp ']' Block	[*
                                                               %% = new ControlNode(ControlNodeKind.for, %1, %3, %4, %5, %6, %8);
                                                               *]
        | foreach Identifier ListLike Block                 [* %% = new ControlNode(ControlNodeKind.foreach, %1, %2, %3, %4); *]
        | forever Block										[* %% = new ControlNode(ControlNodeKind.forever, %1, %2); *]
        | while Expression Block 						    [* %% = new ControlNode(ControlNodeKind.while, %1, %2, %3); *]
        | DoWhile Expression Block						    [* %% = new ControlNode(ControlNodeKind.dowhile, %1, %2, %3); *]
        | waituntil Waituntil_Block				            [* %% = new ControlNode(ControlNodeKind.waituntil, %1, %2); *]
        | wait Expression								    [* %% = new ControlNode(ControlNodeKind.wait, %1, %2); *]
        | waitms Expression								    [* %% = new ControlNode(ControlNodeKind.waitms, %1, %2); *]
        | tag Label											[* %% = new ControlNode(ControlNodeKind.tag, %1, %2); *]
        | goto Identifier									[* %% = new ControlNode(ControlNodeKind.goto, %1, %2);*]
        | stop												[* %% = new ControlNode(ControlNodeKind.return, %1); *]
        | Output Expression	    						    [* %% = new ControlNode(ControlNodeKind.output, %1, %2); *]
        | ProcCall									    	[* %% = langAst.setReturnValueExpected(%1, false); *]
        | ProcCallNoArg								    	[* %% = langAst.setReturnValueExpected(%1, false); *]
        | SendArray									    	[* %% = langAst.setReturnValueExpected(%1, false); *]
        | ReceiveArray									   	[* %% = langAst.setReturnValueExpected(%1, false); *]
        | make ThingVar Expression 							[* %% = new VarAssignmentNode(%1, %2, VarAssignmentNodeKind.make, %3); *]
        | make ThingVar '(' string IntLike ')'                [* %% = createStringDeclaration((%2).token, %5); *]
        | make ThingVar '(' array IntLike ')'                [* %% = createArrayDeclaration((%2).token, %5); *]
        | Motors  									        [* %% = new MotorNode(MotorNodeKind.motor, %1); *]
        | Servos                                            [* %% = new MotorNode(MotorNodeKind.servo, %1); *]
        | Motor_cmd
        | Servo_cmd
        | Data_cmd
        | ledon												[* %% = new CommandNode(CommandNodeKind.ledon, %1); *]
        | ledoff 											[* %% = new CommandNode(CommandNodeKind.ledoff, %1); *]
        | beep 												[* %% = new CommandNode(CommandNodeKind.beep, %1); *]
        | resett 											[* %% = new CommandNode(CommandNodeKind.resett, %1); *]
        | array '[' ArraySpec ']'                           [* %% = setDeclarationToken(%3, %1) ; *]
        | bytearray '[' ArraySpec ']'                       [* %% = langAst.replaceUnknownVarType(%3, [Types.uint8]); *]
        | aset ThingVar Expression Expression                [* %% = new VarAssignmentNode(%1, %2,VarAssignmentNodeKind.aset, %4, %3); *]
        | setitem Expression ThingVar Expression             [* %% = new VarAssignmentNode(%1, %3,VarAssignmentNodeKind.aset, %4, %2); *]
        | local Identifier                                  [* %% = new DeclarationNode(DeclarationNodeKind.local, %1, [Types.unknown], %2); *]
        | digitalout Expression Expression                      [* %% = new CommandNode(CommandNodeKind.digitalout, %1, %2, %3); *]
        | analogout Expression Expression                     [* %% = new CommandNode(CommandNodeKind.analogout, %1, %2, %3); *]
        | ProcDef
        ;



Motor_cmd:		on											[* %% = new CommandNode(CommandNodeKind.on, %1); *]
				| onfor Expression 							[* %% = new CommandNode(CommandNodeKind.onfor, %1, %2); *]
				| off 										[* %% = new CommandNode(CommandNodeKind.off, %1); *]
				| thisway									[* %% = new CommandNode(CommandNodeKind.thisway, %1); *]
				| thatway									[* %% = new CommandNode(CommandNodeKind.thatway, %1); *]
				| rd										[* %% = new CommandNode(CommandNodeKind.rd, %1); *]
				| brake										[* %% = new CommandNode(CommandNodeKind.brake, %1); *]
				| setpower Expression						[* %% = new CommandNode(CommandNodeKind.setpower, %1, %2); *]
				;

Servo_cmd:		setsvh Expression  							[* %% = new CommandNode(CommandNodeKind.setsvh, %1, %2); *]
				| svr Expression  							[* %% = new CommandNode(CommandNodeKind.svr, %1, %2); *]
				| svl Expression  							[* %% = new CommandNode(CommandNodeKind.svl, %1, %2); *]
				;

Data_cmd:		resetdp										[* %% = new CommandNode(CommandNodeKind.resetdp, %1); *]
                | setdp	Expression						    [* %% = new CommandNode(CommandNodeKind.setdp, %1, %2); *]
				| record Expression							[* %% = new CommandNode(CommandNodeKind.record, %1, %2); *]
				| erase Expression							[* %% = new CommandNode(CommandNodeKind.erase, %1, %2); *]
				| send Expression							[* %% = new CommandNode(CommandNodeKind.send, %1, %2); *]
				| i2cstart                                          [* %% = new CommandNode(CommandNodeKind.i2c, %1); *]
                | i2cstop                                           [* %% = new CommandNode(CommandNodeKind.i2c, %1); *]
                | i2cwrite Expression Expression IntLike Variable Expression [*
                                                                        %% = new CommandNode(CommandNodeKind.i2c,
                                                                                             %1, %2, %3, %4, %5, %6); *]
                | i2cread Expression Expression IntLike Variable Expression [*
                                                                        %% = new CommandNode(CommandNodeKind.i2c,
                                                                                             %1, %2, %3, %4, %5, %6); *]
				;

Expression:		  ThingVar                           [* %% = new VarFetchNode(%1, %1, VarFetchNodeKind.variable, [Types.unknown]); *]
				| MathExp
				| BoolExp
				| StringExp
				| '(' Expression ')'							[* %% = %2; *]
				;

StringExp:      StringLit                                       [* %% = createStringLiteralNode(%1); *]
				| tostring Expression                           [* %% = new ExpressionNode(%1, ExpressionNodeKind.convert, (%1).value, [Types.string(0)], %2); *]
				;

MathExp:		  Expression '-' Expression                 [* %% = new ExpressionNode(%2, ExpressionNodeKind.math, "sub", [Types.unknown], %1, %3); *]
				| difference Expression Expression        [* %% = new ExpressionNode(%1, ExpressionNodeKind.math, "sub", [Types.unknown], %1, %3); *]
				| Expression '+' Expression               [* %% = new ExpressionNode(%2, ExpressionNodeKind.math, "add", [Types.unknown], %1, %3); *]
				| sum Expression Expression               [* %% = new ExpressionNode(%1, ExpressionNodeKind.math, "add", [Types.unknown], %1, %3); *]
				| Expression '*' Expression               [* %% = new ExpressionNode(%2, ExpressionNodeKind.math, "mul", [Types.unknown], %1, %3); *]
                | product Expression Expression           [* %% = new ExpressionNode(%1, ExpressionNodeKind.math, "mul", [Types.unknown], %1, %3); *]
                | Expression '/' Expression               [* %% = new ExpressionNode(%2, ExpressionNodeKind.math, "div", [Types.unknown], %1, %3); *]
                | quotient Expression Expression          [* %% = new ExpressionNode(%1, ExpressionNodeKind.math, "div", [Types.unknown], %1, %3); *]
                | Expression '%' Expression               [* %% = new ExpressionNode(%2, ExpressionNodeKind.math, "mod", [Types.unknown], %1, %3); *]
                | modulo Expression Expression	        [* %% = new ExpressionNode(%1, ExpressionNodeKind.math, "mod", [Types.unknown], %1, %3); *]
                | MathFuncExp
                | BitwiseExp
				| NegExp
				| ascii Expression                [* %% = new ExpressionNode(%1, ExpressionNodeKind.convert, (%1).value, [Types.uint8], %2); *]
				| count Expression                [* %% = new ExpressionNode(%1, ExpressionNodeKind.convert, (%1).value, [Types.uint8], %2); *]
				| '(' MathExp ')'				    [* %% = %2; *]
				;

MathFuncExp:      min Expression Expression             [* %% = new ExpressionNode(%1, ExpressionNodeKind.math, (%1).value, [Types.unknown], %2, %3); *]
                | max Expression Expression             [* %% = new ExpressionNode(%1, ExpressionNodeKind.math, (%1).value, [Types.unknown], %2, %3); *]
                | abs Expression                     [* %% = new ExpressionNode(%1, ExpressionNodeKind.math, (%1).value, [Types.unknown], %2); *]
                | neg Expression                     [* %% = new ExpressionNode(%1, ExpressionNodeKind.math, (%1).value, [Types.unknown], %2); *]
                | pow Expression Expression             [* %% = new ExpressionNode(%1, ExpressionNodeKind.math, (%1).value, [Types.float], %2, %3); *]
                | sqr Expression                     [* %% = new ExpressionNode(%1, ExpressionNodeKind.math, (%1).value, [Types.float], %2); *]
                | sqrt Expression                    [* %% = new ExpressionNode(%1, ExpressionNodeKind.math, (%1).value, [Types.float], %2); *]
                | exp Expression                     [* %% = new ExpressionNode(%1, ExpressionNodeKind.math, (%1).value, [Types.float], %2); *]
                | sin Expression                     [* %% = new ExpressionNode(%1, ExpressionNodeKind.math, (%1).value, [Types.float], %2); *]
                | cos Expression                     [* %% = new ExpressionNode(%1, ExpressionNodeKind.math, (%1).value, [Types.float], %2); *]
                | tan Expression                     [* %% = new ExpressionNode(%1, ExpressionNodeKind.math, (%1).value, [Types.float], %2); *]
                | asin Expression                    [* %% = new ExpressionNode(%1, ExpressionNodeKind.math, (%1).value, [Types.float], %2); *]
                | acos Expression                    [* %% = new ExpressionNode(%1, ExpressionNodeKind.math, (%1).value, [Types.float], %2); *]
                | atan Expression                    [* %% = new ExpressionNode(%1, ExpressionNodeKind.math, (%1).value, [Types.float], %2); *]
                | atan2 Expression Expression           [* %% = new ExpressionNode(%1, ExpressionNodeKind.math, (%1).value, [Types.float], %2, %3); *]
                | sinh Expression                    [* %% = new ExpressionNode(%1, ExpressionNodeKind.math, (%1).value, [Types.float], %2); *]
                | cosh Expression                    [* %% = new ExpressionNode(%1, ExpressionNodeKind.math, (%1).value, [Types.float], %2); *]
                | tanh Expression                    [* %% = new ExpressionNode(%1, ExpressionNodeKind.math, (%1).value, [Types.float], %2); *]
                | hypot Expression Expression           [* %% = new ExpressionNode(%1, ExpressionNodeKind.math, (%1).value, [Types.float], %2, %3); *]
                | ln Expression                      [* %% = new ExpressionNode(%1, ExpressionNodeKind.math, (%1).value, [Types.float], %2); *]
                | log10 Expression                   [* %% = new ExpressionNode(%1, ExpressionNodeKind.math, (%1).value, [Types.float], %2); *]
                | Round Expression                     [* %% = new ExpressionNode(%1, ExpressionNodeKind.math, "rnd", [Types.float], %2); *]
                | Trunc Expression                   [* %% = new ExpressionNode(%1, ExpressionNodeKind.math, "trunc", [Types.float], %2); *]
                | Floor Expression                   [* %% = new ExpressionNode(%1, ExpressionNodeKind.math, "floor", [Types.float], %2); *]
                | Ceil Expression                    [* %% = new ExpressionNode(%1, ExpressionNodeKind.math, "ceil", [Types.float], %2); *]
                ;

BitwiseExp:        bitand Expression Expression        [* %% = new ExpressionNode(%1, ExpressionNodeKind.math, (%1).value, [Types.unknown], %2, %3); *]
                | bitor  Expression Expression        [* %% = new ExpressionNode(%1, ExpressionNodeKind.math, (%1).value, [Types.unknown], %2, %3); *]
                | bitxor Expression Expression        [* %% = new ExpressionNode(%1, ExpressionNodeKind.math, (%1).value, [Types.unknown], %2, %3); *]
                | bitnot Expression Expression        [* %% = new ExpressionNode(%1, ExpressionNodeKind.math, (%1).value, [Types.unknown], %2, %3); *]
                | ashift Expression Expression        [* %% = new ExpressionNode(%1, ExpressionNodeKind.math, (%1).value, [Types.unknown], %2, %3); *]
                | lshift Expression Expression        [* %% = new ExpressionNode(%1, ExpressionNodeKind.math, (%1).value, [Types.unknown], %2, %3); *]
                | rotate Expression Expression        [* %% = new ExpressionNode(%1, ExpressionNodeKind.math, (%1).value, [Types.unknown], %2, %3); *]
                ;

NegExp:			'-' NumericValue		&'*'    [* %% = new ExpressionNode(%1, ExpressionNodeKind.math, "neg", [Types.unknown], %2); *]
				| NumericValue
				;

Value:			NumericValue
				| BoolValue
				| '(' Value ')'
				;

BoolExp:		  Expression '=' Expression			[* %% = new ExpressionNode(%2, ExpressionNodeKind.logic, "eq", [Types.bool], %1, %3); *]
                | Expression '<>' Expression		[* %% = new ExpressionNode(%2, ExpressionNodeKind.logic, "ne", [Types.bool], %1, %3); *]
				| Expression '<' Expression		 	[* %% = new ExpressionNode(%2, ExpressionNodeKind.logic, "lt", [Types.bool], %1, %3); *]
				| Expression '>' Expression			[* %% = new ExpressionNode(%2, ExpressionNodeKind.logic, "gt", [Types.bool], %1, %3); *]
				| Expression '<=' Expression		[* %% = new ExpressionNode(%2, ExpressionNodeKind.logic, "le", [Types.bool], %1, %3); *]
				| Expression '>=' Expression		[* %% = new ExpressionNode(%2, ExpressionNodeKind.logic, "ge", [Types.bool], %1, %3); *]
				| not Expression						[* %% = new ExpressionNode(%1, ExpressionNodeKind.logic, (%1).value, [Types.bool], %2); *]
				| and Expression Expression				[* %% = new ExpressionNode(%1, ExpressionNodeKind.logic, (%1).value, [Types.bool], %2, %3); *]
				| or Expression Expression				[* %% = new ExpressionNode(%1, ExpressionNodeKind.logic, (%1).value,  [Types.bool], %2, %3); *]
				| xor Expression Expression				[* %% = new ExpressionNode(%1, ExpressionNodeKind.logic, (%1).value, [Types.bool], %2, %3); *]
				| BoolValue
				| '(' BoolExp ')'					[* %% = %2; *]
				;

BoolValue:		  true								[* %% = new _ImmediateNode([Types.bool], %1); *]
				| false								[* %% = new _ImmediateNode([Types.bool], %1); *]
				| Switchn							[* %% = new InputNode(InputNodeKind.switch, %1, [Types.bool], %1); *]
				| Received Expression		        [* %% = new CommandNode(CommandNodeKind.received, %1, %2); *]
				| Received						    [* %% = new CommandNode(CommandNodeKind.received, %1); *]
                | digitalin	Expression			    [* %% = new InputNode(InputNodeKind.digitalin, %1, [Types.bool], %2); *]
				| ProcCall			  				[* %% = langAst.setReturnValueExpected(%1, true); *]
				| ProcCallNoArg			  			[* %% = langAst.setReturnValueExpected(%1, true); *]
				| IsNan Expression                     [* %% = new ExpressionNode(ExpressionNodeKind.logic, "isnan", [Types.bool], %2); *]
                | IsInf Expression                     [* %% = new ExpressionNode(ExpressionNodeKind.logic, "isinf", [Types.bool], %2); *]
				;

NumericValue:	IntLike
				| Double							    [* %% = new _ImmediateNode([Types.double], %1); *]
				| Float							        [* %% = new _ImmediateNode([Types.float], %1); *]
				| E							            [* %% = new _ImmediateNode([Types.float], %1); *]
                | PI							        [* %% = new _ImmediateNode([Types.float], %1); *]
                | LN2							        [* %% = new _ImmediateNode([Types.float], %1); *]
                | LN10							        [* %% = new _ImmediateNode([Types.float], %1); *]
                | LOG2E							        [* %% = new _ImmediateNode([Types.float], %1); *]
                | LOG10E					            [* %% = new _ImmediateNode([Types.float], %1); *]
                | SQRT1_2						        [* %% = new _ImmediateNode([Types.float], %1); *]
                | SQRT2							        [* %% = new _ImmediateNode([Types.float], %1); *]
                | repcount                              [* %% = new InputNode(InputNodeKind.repcount, %1, [Types.uint16]); *]
				| recall						        [* %% = new InputNode(InputNodeKind.recall, %1, [Types.int16]); *]
				| timer								    [* %% = new InputNode(InputNodeKind.timer, %1, [Types.uint16]); *]
				| random Expression Expression		    [* %% = new InputNode(InputNodeKind.random, %1, [Types.int16], %2, %3); *]
				| random							    [* %% = new InputNode(InputNodeKind.random, %1, [Types.uint16]); *]
				| Sensorn							    [* %% = new InputNode(InputNodeKind.sensor, %1, [Types.uint16], %1); *]
				| receive							    [* %% = new CommandNode(CommandNodeKind.receive, %1); *]
				| analogin	Expression				    [* %% = new InputNode(InputNodeKind.analogin, %1, [Types.uint16], %2); *]
				| ProcCall			  				    [* %% = langAst.setReturnValueExpected(%1, true); *]
				| ProcCallNoArg			  			    [* %% = langAst.setReturnValueExpected(%1, true); *]
				| aget ThingVar Expression              [* %% = new VarFetchNode(%1, %2, VarFetchNodeKind.aget, [Types.unknown], %3); *]
				| item Expression ThingVar              [* %% = new VarFetchNode(%1, %3, VarFetchNodeKind.aget, [Types.unknown], %2); *]
				| i2cerr                                [* %% = new InputNode(InputNodeKind.i2cerr, %1, [Types.uint32]); *]
				| SendArray			  				    [* %% = langAst.setReturnValueExpected(%1, true); *]
				| ReceiveArray		  				    [* %% = langAst.setReturnValueExpected(%1, true); *]
				;

IntLike:        Short								[* %% = new _ImmediateNode([Types.int16], %1); *]
				| UShort							[* %% = new _ImmediateNode([Types.uint16], %1); *]
				| Integer							[* %% = new _ImmediateNode([Types.int32], %1); *]
				| UInteger							[* %% = new _ImmediateNode([Types.uint16], %1); *]
				;
				


[*

module.exports.parse = __LogoCCparse;
module.exports.ast   = _ast;
*]
